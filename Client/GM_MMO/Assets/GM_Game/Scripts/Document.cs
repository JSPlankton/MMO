using UnityEngine;

/**
 * Title:开发笔记
 * Description:Unity中组件，插件等等功能的介绍
 */


public class Document
{

    #region Camera

    /**
     * Camera是Unity中非常重要的组件，它主要用于生成和展示游戏画面，也就是它决定了画面最后的输出内容。
     * 
     * Camera的基本属性和功能：
     * 
     *      ‌1.Clear Flags‌：决定将清除屏幕的哪些部分。例如，使用多个摄像机时，可以方便地绘制不同游戏元素。
     *      2.‌Background‌：在绘制视图中的所有元素之后，应用于剩余屏幕部分的颜色。
     *      3.‌Culling Mask‌：选择哪些Layer的物体能被摄像机渲染。
     *      4.‌Projection‌：有两种模式，‌Perspective‌（透视模式，近大远小）和‌Orthographic‌（正交模式，视野范围是一个长方体）。
     *      5.‌Field of View‌：透视模式下的视场角宽度。
     *      6.‌Size‌：正交模式下的视野范围大小。
     *      7.‌Clipping Planes‌：定义摄像机可以渲染的最近和最远距离。
     *      8.‌Viewport Rect‌：指定相机的画面在屏幕中的位置和大小。
     *      
     * Camera的高级属性和功能：
     * 
     *      1.Rendering Path‌：定义摄像机将使用的渲染方法，如Forward Rendering或Deferred Lighting。
     *      2.‌Layer Mask‌：通过Culling Mask设置哪些Layer的物体可以被摄像机渲染。
     *      3.‌Depth‌：在绘制顺序中的位置，深度值较大的摄像机将绘制在深度值较小的摄像机之上。
     * 
     * 性能优化技巧：
     *      
     *      1.剔除优化‌：通过Culling Mask排除不符合条件的Renderer，减少GPU绘制的工作量。 
     *      2.视锥剔除和遮挡剔除‌：进一步优化渲染顺序，先绘制不透明的物体，再绘制透明的物体。
     *      3.‌Render Queue‌：根据材质或Shader的Render Queue来优化渲染顺序，提高渲染效率。
     * 
     */
    #endregion

    #region Canvas

    /**
     * Canvas组件是UI系统的核心组件，它作为所有UI元素的容器，负责管理和渲染用户界面。
     * 
     *  它是Unity引擎自带的UI系统，叫UGUI。它是目前使用最广泛的UI系统，
     *  在Unity4.6之前，它默认使用的是GUI，由于GUI不能实时的和渲染，只有在项目运行的时候才可以看到效果，
     *  所以在4.6之后就推出了UGUI，它的比GUI搭建更方便，功能完善，使用也更加容易，经过这么久的发展，相对也非常的稳定了哈 ,而它的缺点就是行不是很好。
     *  Unity在后续又推出了UI Toolkit,它的性能高，但是还不够完善，不过目前还在持续更新中,
     * 
     * Canvas的三种渲染模式：
     *      
     *      1.Screen Space-Overlay, 在此模式下，Canvas会覆盖整个屏幕，所有UI元素的坐标是基于屏幕空间的，UI元素也始终在屏幕的最前面，
	 *		不受场景和摄像机的影响，即使没有摄像机也可以渲染UI。
     *      2.ScreenSpace -Camera:就是指定某一个Camera来渲染UI，游戏对象可以在UI前面，他也是基于屏幕空间，但受摄像机影响，
	 *		UI元素会随摄像机的移动旋转而变化。
     *      3.World Space：在这种模式下，Canvas会作为3D场景的一部分，UI元素的坐标是基于世界空间的，它也可以像3D对象一样，存在与场景中。
     *      
     */

    #endregion

    #region UI适配

    /**
     * UI适配（UI Adaptation） 是确保用户界面在不同屏幕分辨率、设备比例和方向下正确显示的核心任务。
     *           
     * 
     *      1、UI元素的适配：在设计UI时，常常需要考虑屏幕分辨率和设备尺寸等因素。为了让UI在不同的设备上呈现出较好的效果，需要对UI元素进行适配。
     *      2、Canvas Scaler它提供了3种缩放模式：
     *              (1)Constant Pixel Size（固定像素大小）：这种方式下，UI元素的尺寸将按照在设计时所设置的像素大小来显示，不会发生缩放。
     *              (2)Scale with Screen Size（根据屏幕尺寸进行缩放）：这种方式下，UI元素的尺寸将会根据屏幕的大小进行缩放
     *              (3)Constant Physical Size（固定物理大小）：这种方式下，UI元素的尺寸将会根据物理尺寸来显示。
     *                                                         这意味着，UI元素的物理大小将始终保持不变，而不是根据屏幕尺寸进行缩放
     *      3、RectTransform下的Anchor Points的妙用：                                                     
     * 
     */

    #endregion

    #region Prefab

    /**
     * Prefab：是一种可实例化的资源文件，用于快速创建和复用场景中的对象。Prefab是游戏对象及其组件（如Transform、MeshRenderer、脚本）的模板，
     *      存储对象的配置和状态。其核心作用包括复用性、一致性和模块化开发。
     * 
     * Prefab的基本概念和作用：
     *      1、定义：Prefab是游戏对象及其组件的模板，用于快速创建和复用场景中的对象。它是一种可实例化的资源文件（.prefab），存储对象的配置和状态。
     *      2、‌核心作用‌：‌复用性‌：一次创建，多次实例化。
     *                   ‌一致性‌：修改预制体可同步更新所有实例。
     *                   模块化开发‌：将复杂对象封装为预制体，便于团队协作。
     * 
     */

    #endregion

    #region MonoBehaviour的生命周期函数

    /**
     * //MonoBehaviour的生命周期函数，可以分为3个阶段
     * 
	 * 1.初始化阶段:
     *          Awake()：脚本被加载的时候嗲用，最先执行的生命周期函数，在脚本整个生命周期内它仅被调用一次 ，在这函数里面可以初始脚本变量和设置对象的初始状态
	 *                 我们在它里面打印一条打印信息.
	 *          OnEnable():当脚本被激活的时候调用..每激活一次调用一次该函数.  用于处理对象激活时的逻辑.
	 *          Start()：在所有Awake()方法调用完成后并且所有游戏对象已启用时调用,它在Update之前会调用一次，用于脚本的初始设置和游戏逻辑初始化。
     * 
     * 2.更新阶段: 
     *          FixedUpdate():  每固定时间间隔调用一次，通常是0.02s。   
     *          Update(): 每帧调用一次。
     *          LateUpdate(): 在所有Update()方法之后调用。
     * 
     * 3.摧毁阶段:
     *          OnApplicationQuit():  当应用程序退出时调用。
     *          OnDisable(): 当脚本或游戏对象被禁用时调用。
     *          OnDestroy(): 当游戏对象被销毁时调用。
     */

    #endregion

    #region SerializeField

    /**
     * ‌SerializeField：是Unity引擎中的一个属性（Attribute），用于指示一个私有字段（private field）应该被序列化。
     *              这意味着即使该字段是私有的，Unity的序列化系统也能够访问并保存它的值。这对于在游戏运行时保存和加载游戏状态非常有用。
     * 
     */

    #endregion

    #region DoTween

    /**
     * Dotween：一个强大的动画插件，专为Unity3D设计，提供了高效且易于使用的动画解决方案。 
     * 
     * 功能和优势：DOTween主要用于创建插值动画，支持各种类型的动画效果，如平移、旋转、缩放、颜色渐变等。
     *             它特别适合用于UI动画、物体的动态效果以及渐变动画等场景‌。 
     *  
     *      1、高性能‌：相比传统的动画系统，DOTween的执行效率更高，适用于大量物体的同时动画处理‌。
     *      2、易于使用‌：通过简洁的API和链式调用，可以轻松创建复杂的动画‌。
     *      3、灵活性‌：支持序列动画、延时动画、回调函数、动画的暂停与恢复等功能‌。
     *      4、组合性强‌：支持Sequence（序列动画）、Loop（循环动画）、Easing（缓动）等多种动画控制‌
     *      
     */

    #endregion

    #region  Unity中的输入系统

    /**
     * 在Unity中：输入系统是负责接收和处理来自各种输入设备(鼠标，键盘，手柄，触摸屏等等)的用户输入，
     *            将其转换为游戏逻辑可以使用的事件和数据。
     * 
     * Unity种目前有2种输入系统:
     *          
     *          1.旧输入系统(Legacy Input Manager):它是基于Input类，使用静态接口访问输入数据。
     *                          它的优点:简单易用，适合大多数基础输入需求。
     *                          缺点:功能有限，扩展性差，不支持复杂输入映射和多设备管理。
     *                          
     *          2.新输入系统(Input System Package)：它是基于模块化，事件驱动。支持更多设备和复杂输入映射。
     *                          优点:灵活且强大，支持多设备，多平台，易于扩展和维护，
     *                          缺点：学习难度加大，配置较为复杂。
     * 
     * 至于底层原理，有兴趣的同学可以去了解下
     * 
     */


    #endregion

    #region HybridCLR简介

    /**
     * HybridCLR:是一个特性完整、零成本、高性能、低内存的近乎完美的Unity全平台原生C#热更方案。
     * 
     *  原理：通过扩充IL2CPP运行时代码，使其由纯AOT runtime变成AOT+Interpreter混合runtime，
	 *				从而原生支持动态加载assembly，从底层彻底支持了热更新‌
     * 
     *  优点：
     *      1.易于使用： 原生C#热更新体验，开发工作流与传统Unity C#开发几乎相同，零学习和使用成本。
     *      2.实现高效：C++实现，与il2cpp高级集成，运行性能和内存占用指标都远远优于其他任何热更新方案。
     *                  开创性的DHE技术让热更新的游戏逻辑的运行性能基本达到原生AOT的水平。
     *      3.稳定可靠:极其稳定可靠，足以满足大中型商业项目的稳定性要求。当前上千个商业游戏项目完成接入，
     *                 其中有几百款已经双端上线。大多数头部公司如腾讯、网易、字节、funplus都已接入。
     *                 
     */

    #endregion

    #region YooAsset简介


    /**
     * YooAsset:是U3D的资源管理系统，它可以帮助我们更加高效地管理游戏中的各种资源
     * 
     *  功能:
     *      1.异步加载‌：YooAsset支持异步加载资源，提高游戏的加载速度，减少卡顿现象‌
     *      2.‌资源缓存‌：可以缓存已加载的资源，避免重复加载，降低内存占用‌
     *      3.依赖关系管理‌：自动识别资源之间的依赖关系，避免资源丢失‌
     *      4.资源卸载‌：在资源不再使用时自动卸载，释放内存‌
     * 
     * 	优点：
     *      1.易于上手：不需要复杂的界面配置，专注于中国开发者的使用体验，可以帮助研发团队快速部署和交付游戏。
     *      2.功能强大：可以满足商业化游戏的各类需求，十大系统特点助力研发团队提高产品品质。
     *      3.永久免费：秉持开源精神，无论是公司或者个人可以永久免费使用。
     */

    #endregion

    #region UniRx
    /**
    * UniRx:‌是一个专为Unity设计的响应式编程库，提供了丰富的功能和灵活的API。
    *  
    *  //观察者模式
    * 
     *  功能:
    *     它主要用于处理异步事件流，帮助开发者更好地管理异步操作和事件处理。
     * 
    * 	优点：
‌    *      1.简洁的事件处理‌：提供简洁的API，易于处理复杂的事件流。
    *		‌2.强大的组合操作‌：丰富的操作符支持对事件流进行各种操作。
    *		‌3.与Unity无缝集成‌：支持Unity的各种事件，如Update、FixedUpdate、OnDestroy等。
    *		4.‌提高代码可读性‌：响应式编程使代码更加简洁和易读，减少回调地狱和状态管理的复杂性。
    *		
    */

    #endregion


    #region MVC设计模式
    /**
    * MVC:Model-View-Controller：是一种软件架构模式，是软件设计模式的体现。
    *                           用于组织代码并分离关注点，广泛应用于用户界面的开发中
    *                           该模式将相关程序逻辑划分为三个相互关联的组成部分：模型、视图和控制器
    *  
    *   在MVC架构中，Controller是业务的主要承载者，几乎所有的业务逻辑都在Controller中进行编写。
    *              而View主要负责UI逻辑，而Model是数据逻辑，彼此分工。
    *              
    * 	优点：
‌    *       1.清晰的结构：MVC将应用程序分为三部分——模型（Model）、视图（View）和控制器（Controller），使代码结构清晰，维护性好，便于开发人员理解和修改。
	*       2.高可维护性：由于代码分离，修改业务逻辑时无需更改视图，视图的更改也不会影响控制器，便于模块化开发和后期维护。
	*       3.可重用性高：模型和视图的解耦使得相同的模型可以在不同的视图中使用，减少了代码冗余，提高了代码复用性。
	*       4.并行开发：MVC的分离允许团队中的开发人员并行工作，例如后端开发人员可以专注于模型和控制器，而前端开发人员专注于视图的实现。
    *		
    */

    #endregion

    #region cinemachine

    /*
     * 
     *  Cinemachine:是Unity官方提供的智能相机系统，用于简化游戏和实时3D内容中的摄像机控制，无需编写大量代码即可实现复杂的相机行为‌。
     *              它支持动态跟踪、镜头混合、路径动画等功能，广泛应用于过场动画、角色跟随和场景切换等场景
     *              通过虚拟摄像机（Virtual Camera）和 Cinemachine Brain 来实现复杂的相机行为和镜头过渡，极大地简化了相机控制的复杂度
     *              
     *  核心功能与特性:
     *              1.‌无需编写代码‌：Cinemachine允许用户通过配置而不是编写代码来控制相机行为，使得非程序员也能轻松使用
     *              2.虚拟摄像机‌：Cinemachine引入了虚拟摄像机的概念，用户可以通过虚拟摄像机来管理实际的摄像机，而不需要直接操作实际的摄像机对象。              
     *              3.目标跟踪‌：Cinemachine能够自动跟踪和对焦游戏中的目标，使相机的运动更加平滑和自然。
     *              4.多摄像机管理‌：它能够管理多个摄像机，并根据优先级和条件自动切换它们，以实现更流畅的镜头过渡。
     *              5.‌镜头切换‌：支持创建切换镜头的区域，以便在游戏中实现不同的视角和效果。             
     *              6.‌轨道系统‌：引入了轨道的概念，允许开发人员在3D空间中定义相机的运动路径，实现更复杂的镜头动画
     *              7.渐变效果‌：提供了通过 Impulse Listener 实现相机渐变效果的功能，使相机对游戏中的事件有更生动的响应。
     * 
     */
    #endregion


    #region FSM

    /*
     * 
     *  Unity 有限状态机 （FSM）是一种用于管理对象状态转换的设计模式，
     *                      通过定义状态、转换条件和事件来控制行为逻辑，尤其适用于处理复杂游戏逻辑和离散事件
     *              
     *  作用:
     *         1.‌简化复杂逻辑‌：通过将系统行为分解为有限状态，并定义状态间的转换规则，
     *                              避免复杂的条件判断和嵌套代码结构，提升代码可维护性。
     *         2.状态管理‌：可同时处理多个状态（如攻击、移动、待机等），并控制状态间的平滑切换，例如敌人AI在不同战斗阶段的状态转换              
     *         3.‌事件驱动响应‌：根据事件触发状态迁移或动作，例如角色受伤触发防御状态、获得道具触发升级状态等。
     *  
     *  优势:
     *        ‌模块化设计‌：状态独立管理，便于扩展新功能或修改特定行为逻辑。
     *      ‌  性能高效‌：状态转换逻辑清晰，计算开销低，适合实时系统.
     *        ‌调试友好‌：状态图可视化工具可直观设计状态机结构。
     *      
     */
    #endregion


}
